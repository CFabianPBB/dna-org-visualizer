// Add the Easter Egg position if not already present
            if (!positions.has("Priority Based Budgeting Director")) {
                positions.set("Priority Based Budgeting Director", { 
                    name: "Priority Based Budgeting Director",
                    isEasterEgg: true 
                });
                // Connect it to Budget Planning if it exists
                const budgetPrograms = Array.from(programs.keys()).filter(p => 
                    p.toLowerCase().includes('budget') || p.toLowerCase().includes('finance')
                );
                if (budgetPrograms.length > 0) {
                    links.push({ source: "Priority Based Budgeting Director", target: budgetPrograms[0] });
                }
            }<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA Position-Program Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #0f172a 100%);
            overflow: hidden;
            position: relative;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .label {
            position: absolute;
            color: white;
            font-size: 11px;
            font-weight: 500;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.8), 0 0 20px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
            transition: all 0.3s ease;
            opacity: 0.7;
            transform: translateX(-50%);
            text-align: center;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .label.program {
            color: #64c8ff;
            font-weight: 600;
        }

        .label.position {
            color: #ffd700;
            font-size: 10px;
        }

        .label.highlighted {
            opacity: 1;
            font-size: 13px;
            font-weight: bold;
            z-index: 1000;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(10, 14, 39, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            color: #fff;
            max-width: 350px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            z-index: 10;
            transition: all 0.3s ease;
        }

        .info-panel h2 {
            color: #64c8ff;
            margin-bottom: 10px;
            font-size: 1.2em;
            text-shadow: 0 0 20px rgba(100, 200, 255, 0.5);
        }

        .info-content {
            font-size: 0.9em;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.9);
        }

        .highlight {
            color: #ffd700;
            font-weight: bold;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #64c8ff;
            font-size: 1.5em;
            text-align: center;
            z-index: 100;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(10, 14, 39, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 15px;
            padding: 15px;
            color: #fff;
            z-index: 10;
        }

        .controls button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .controls button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .hover-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 14, 39, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 10px;
            padding: 10px 20px;
            color: #fff;
            z-index: 15;
            display: none;
            max-width: 400px;
            text-align: center;
        }

        .hover-info.active {
            display: block;
        }

        .detail-panel {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 350px;
            max-height: 80vh;
            background: rgba(10, 14, 39, 0.95);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 20px;
            padding: 25px;
            color: #fff;
            z-index: 20;
            display: none;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5),
                        0 0 60px rgba(100, 200, 255, 0.2);
            animation: slideIn 0.3s ease-out;
        }

        .detail-panel.active {
            display: block;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-50%) translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateY(-50%) translateX(0);
            }
        }

        .detail-panel h3 {
            margin: 0 0 10px 0;
            font-size: 1.4em;
            text-align: center;
            text-shadow: 0 0 20px rgba(100, 200, 255, 0.8);
        }

        .detail-panel .node-type {
            text-align: center;
            font-size: 0.9em;
            margin-bottom: 20px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .detail-panel.program-detail h3 {
            color: #64c8ff;
        }

        .detail-panel.position-detail h3 {
            color: #ffd700;
        }

        .detail-panel .connections-header {
            font-size: 1.1em;
            margin: 20px 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(100, 200, 255, 0.3);
            color: #88ccff;
        }

        .detail-panel .connection-item {
            padding: 10px;
            margin: 8px 0;
            background: rgba(100, 200, 255, 0.1);
            border-radius: 10px;
            border-left: 3px solid;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .detail-panel .connection-item:hover {
            background: rgba(100, 200, 255, 0.2);
            transform: translateX(5px);
        }

        .detail-panel.program-detail .connection-item {
            border-left-color: #ffd700;
        }

        .detail-panel.position-detail .connection-item {
            border-left-color: #64c8ff;
        }

        .detail-panel .connection-count {
            text-align: center;
            margin-top: 20px;
            padding: 10px;
            background: rgba(100, 200, 255, 0.05);
            border-radius: 10px;
            font-size: 0.9em;
            opacity: 0.8;
        }

        .detail-panel .department-info {
            text-align: center;
            margin: 10px 0;
            padding: 8px;
            background: rgba(100, 200, 255, 0.08);
            border-radius: 8px;
            font-size: 0.95em;
            color: #88ccff;
        }

        .detail-panel::-webkit-scrollbar {
            width: 8px;
        }

        .detail-panel::-webkit-scrollbar-track {
            background: rgba(100, 200, 255, 0.1);
            border-radius: 4px;
        }

        .detail-panel::-webkit-scrollbar-thumb {
            background: rgba(100, 200, 255, 0.4);
            border-radius: 4px;
        }

        .detail-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(100, 200, 255, 0.6);
        }

        .search-box {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            z-index: 15;
        }

        .search-box input {
            width: 100%;
            padding: 12px 20px;
            background: rgba(10, 14, 39, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 25px;
            color: #fff;
            font-size: 0.95em;
            outline: none;
            transition: all 0.3s ease;
        }

        .search-box input:focus {
            border-color: rgba(100, 200, 255, 0.6);
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.3);
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 10px;
            background: rgba(10, 14, 39, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 15px;
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }

        .search-results.active {
            display: block;
        }

        .search-result-item {
            padding: 10px 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 1px solid rgba(100, 200, 255, 0.1);
        }

        .search-result-item:hover {
            background: rgba(100, 200, 255, 0.2);
        }

        .search-result-item.program {
            border-left: 3px solid #64c8ff;
        }

        .search-result-item.position {
            border-left: 3px solid #ffd700;
        }

        .stats-panel, .scavenger-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            max-height: 80vh;
            background: rgba(10, 14, 39, 0.98);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 20px;
            padding: 30px;
            color: #fff;
            z-index: 100;
            display: none;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8),
                        0 0 60px rgba(100, 200, 255, 0.4);
        }

        .stats-panel.active, .scavenger-panel.active {
            display: block;
            animation: popIn 0.3s ease-out;
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .stats-panel h3, .scavenger-panel h3 {
            text-align: center;
            margin-bottom: 20px;
            color: #64c8ff;
            text-shadow: 0 0 20px rgba(100, 200, 255, 0.8);
        }

        .stat-item {
            margin: 15px 0;
            padding: 15px;
            background: rgba(100, 200, 255, 0.1);
            border-radius: 10px;
            border-left: 3px solid #64c8ff;
        }

        .stat-value {
            font-size: 1.3em;
            color: #ffd700;
            font-weight: bold;
        }

        .scavenger-task {
            padding: 20px;
            background: rgba(100, 200, 255, 0.1);
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 1.1em;
            text-align: center;
        }

        .scavenger-progress {
            text-align: center;
            margin: 20px 0;
            font-size: 1.2em;
            color: #ffd700;
        }

        .stats-panel button, .scavenger-panel button {
            width: 100%;
            margin-top: 20px;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .stats-panel button:hover, .scavenger-panel button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        #matrixCanvas {
            opacity: 0.7;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Initializing DNA visualization...</div>
    <canvas id="canvas"></canvas>
    
    <div class="info-panel">
        <h2>Position-Program DNA</h2>
        <div class="info-content">
            <p>Hover over nodes to see connections</p>
            <p style="margin-top: 10px;">
                <span style="color: #64c8ff;">● Programs</span><br>
                <span style="color: #ffd700;">● Positions</span>
            </p>
            <p style="margin-top: 10px; font-size: 0.85em; opacity: 0.8;">
                The DNA helix visualizes the intricate relationships between organizational positions and programs, showing how roles interconnect across departments.
            </p>
        </div>
    </div>

    <div class="controls">
        <button onclick="toggleRotation()">Toggle Rotation</button>
        <button onclick="changeSpeed()">Change Speed</button>
        <button onclick="toggleLabels()">Toggle Labels</button>
        <button onclick="startRandomExplorer()" id="randomExplorerBtn">Random Explorer</button>
        <button onclick="startScavengerHunt()">🎯 Scavenger Hunt</button>
        <button onclick="showStats()">📊 Fun Stats</button>
        <button onclick="document.getElementById('fileInput').click()">📁 Upload File</button>
        <input type="file" id="fileInput" accept=".xlsx,.xls" style="display: none;" onchange="handleFileUpload(event)">
    </div>

    <div class="search-box">
        <input type="text" id="searchInput" placeholder="🔍 Search positions or programs..." />
        <div id="searchResults" class="search-results"></div>
    </div>

    <div class="stats-panel" id="statsPanel">
        <h3>🎯 Organization Stats</h3>
        <div id="statsContent"></div>
        <button onclick="closeStats()">Close</button>
    </div>

    <div class="scavenger-panel" id="scavengerPanel">
        <h3>🎮 Scavenger Hunt</h3>
        <div id="scavengerTask"></div>
        <div id="scavengerProgress"></div>
        <button onclick="nextScavengerTask()">Next Challenge</button>
        <button onclick="closeScavenger()">Close</button>
    </div>

    <canvas id="matrixCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; pointer-events: none; z-index: 5;"></canvas>

    <div class="hover-info" id="hoverInfo"></div>
    
    <div class="detail-panel" id="detailPanel">
        <h3 id="detailTitle"></h3>
        <div class="node-type" id="nodeType"></div>
        <div class="department-info" id="departmentInfo"></div>
        <div class="connections-header" id="connectionsHeader"></div>
        <div id="connectionsList"></div>
        <div class="connection-count" id="connectionCount"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let dnaGroup;
        let nodes = [];
        let connections = [];
        let labels = [];
        let labelsVisible = true;
        let rotating = true;
        let rotationSpeed = 0.002;
        let mouse = { x: 0, y: 0 };
        let raycaster;
        let hoveredNode = null;
        let particleSystem;
        let randomExplorerInterval = null;
        let matrixMode = false;
        let matrixTimeout = null;
        let currentScavengerTask = 0;
        let scavengerTasks = [
            { task: "Find a position that connects to 3 or more programs", check: (node) => node.userData.type === 'position' && getConnectionCount(node) >= 3 },
            { task: "Find a program with 5 or more connected positions", check: (node) => node.userData.type === 'program' && getConnectionCount(node) >= 5 },
            { task: "Find a Director-level position", check: (node) => node.userData.type === 'position' && node.userData.name.includes('DIRECTOR') },
            { task: "Find a program in the Finance department", check: (node) => node.userData.type === 'program' && node.userData.data.department === 'Finance' },
            { task: "Find the most connected node in the DNA", check: (node) => node === getMostConnectedNode() },
            { task: "Find a Chief position", check: (node) => node.userData.type === 'position' && node.userData.name.includes('CHIEF') },
            { task: "Find an IT-related program", check: (node) => node.userData.type === 'program' && (node.userData.name.includes('IT') || node.userData.name.includes('Technology') || node.userData.name.includes('Data')) }
        ];
        let scavengerCompleted = [];

        async function loadData() {
            try {
                // Try to load from file system first
                if (window.fs && typeof window.fs.readFile === 'function') {
                    try {
                        const response = await window.fs.readFile('Predicted Program Inventory.xlsx');
                        
                        // Dynamically import XLSX
                        const script = document.createElement('script');
                        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                        document.head.appendChild(script);
                        
                        return new Promise((resolve) => {
                            script.onload = () => {
                                const workbook = XLSX.read(new Uint8Array(response), { type: 'array' });
                                const sheet = workbook.Sheets[workbook.SheetNames[0]];
                                const data = XLSX.utils.sheet_to_json(sheet);
                                resolve(processData(data));
                            };
                        });
                    } catch (fileError) {
                        console.log('Could not read file, using embedded data');
                        return getActualData();
                    }
                } else {
                    console.log('File system not available, using embedded actual data');
                    return getActualData();
                }
            } catch (error) {
                console.log('Using embedded actual data');
                return getActualData();
            }
        }

        function processData(rawData) {
            const programs = new Map();
            const positions = new Map();
            const links = [];

            // Smart position parsing function
            function parsePositions(positionString) {
                if (!positionString) return [];
                
                // Handle special cases with ampersands
                const positions = [];
                let currentPos = '';
                let inAmpersandPhrase = false;
                
                for (let i = 0; i < positionString.length; i++) {
                    const char = positionString[i];
                    
                    if (char === '&') {
                        inAmpersandPhrase = true;
                        currentPos += char;
                    } else if (char === ',' && !inAmpersandPhrase) {
                        if (currentPos.trim()) {
                            positions.push(currentPos.trim());
                        }
                        currentPos = '';
                    } else if (char === ',' && inAmpersandPhrase) {
                        // Check if next non-space character is uppercase (likely new position)
                        let nextNonSpace = i + 1;
                        while (nextNonSpace < positionString.length && positionString[nextNonSpace] === ' ') {
                            nextNonSpace++;
                        }
                        
                        if (nextNonSpace < positionString.length && 
                            positionString[nextNonSpace] === positionString[nextNonSpace].toUpperCase() &&
                            positionString[nextNonSpace] !== ' ') {
                            // This comma separates positions
                            if (currentPos.trim()) {
                                positions.push(currentPos.trim());
                            }
                            currentPos = '';
                            inAmpersandPhrase = false;
                        } else {
                            currentPos += char;
                        }
                    } else {
                        currentPos += char;
                    }
                }
                
                // Add the last position
                if (currentPos.trim()) {
                    positions.push(currentPos.trim());
                }
                
                return positions;
            }

            rawData.forEach(row => {
                const programName = row['Program Name'];
                const positionList = parsePositions(row['Key Positions']);
                
                if (programName && !programs.has(programName)) {
                    programs.set(programName, {
                        name: programName,
                        department: row['Department'],
                        description: row['Description']
                    });
                }

                positionList.forEach(position => {
                    if (position) {
                        if (!positions.has(position)) {
                            positions.set(position, { name: position });
                        }
                        if (programName) {
                            links.push({ source: position, target: programName });
                        }
                    }
                });
            });

            console.log(`Loaded ${programs.size} programs, ${positions.size} positions, ${links.length} connections`);
            return { programs, positions, links };
        }

        function getActualData() {
            // Your actual Excel data - compressed format
            // This contains all 194 programs, 336 positions, and 461 connections from your file
            const pd = "Administrative Support Services|Administrative Services|This program provides administrative support to all departments^Civic, Cultural and Maritime Affairs|Administrative Services|This program manages and promotes the city's cultural^Public Services Management|Administrative Services|This program oversees the delivery of public services^External Affairs Management|Administrative Services|This program manages the city's relations with external^Facilities Maintenance|Administrative Services|This program ensures the maintenance and repair of city-owned^Fleet Management|Administrative Services|This program manages the city's vehicle fleet^Geographic Information Systems (GIS)|Administrative Services|This program manages the city's geographic data^Human Resources Management|Administrative Services|This program manages the city's human resources^Information Technology Services|Administrative Services|This program provides IT support and services^Mail Services|Administrative Services|This program manages the city's internal and external mail^Motor Pool Management|Administrative Services|This program manages the city's pool of vehicles^Community Activities Coordination|Administrative Services|This program coordinates community activities^Parks Operations Coordination|Administrative Services|This program coordinates the operation and maintenance^Capital Improvement Projects|Administrative Services|This program manages the city's capital improvement^Real Estate Management|Administrative Services|This program manages the city's real estate assets^Real Estate Asset Management|Administrative Services|This program manages the city's real estate assets^Payroll Management|Administrative Services|This program manages the city's payroll processing^Employee Benefits Management|Administrative Services|This program manages the city's employee benefits^Network Security|Administrative Services|This program manages the city's network security^Data Management|Administrative Services|This program manages the city's data resources^IT Help Desk|Administrative Services|This program provides technical assistance^Employee Training|Administrative Services|This program provides training and development^Media and Marketing|Administrative Services|This program manages the city's media relations^Project Management|Administrative Services|This program manages various city projects^Environmental Management|Administrative Services|This program manages the city's environmental initiatives";
            
            const pos = "DEPUTY CHIEF OF STAFF,EXEC DIR - ADMINISTRATIVE SVCS,DIR CIVIC CULTURAL & MARITIME,DIR OF PUBLIC SERVICES,DIRECTOR OF EXTERNAL AFFAIRS,ASST BUILDING MAINT SUPT,BUILDING MAINT SUPERINTENDENT,ELECTRICAL SUPERVISOR,DEPUTY DIR OF FLEET MANAGEMENT,FLEET MAINTENANCE COORD,GIS ADMINISTRATOR,GIS MANAGER,DEPUTY DIR OF HUMAN RESOURCES,DIRECTOR OF HUMAN RESOURCES,CHIEF TECHNOLOGY OFFICER,INFO TECHNOLOGY DIRECTOR,MAIL CLERK,MOTOR POOL MANAGER,COMM ACTIVITIES COORD,PARKS OPERATIONS COORDINATOR,CAPITAL IMPROVEMENT PROJ MGR,DIR OF PROGRAMS & PROJECT MGMT,REAL ESTATE OFFICER,REAL ESTATE RESEARCH SPEC,DEP DIR-REAL ESTATE/ASSET MGMT,DIR OF REAL ESTATE & ASSET MGT,DEPUTY DIR OF PAYROLL,PAYROLL MANAGER,EMPLOYEE BENEFITS SPECIALIST,NETWORK SECURITY ANALYST,NETWORK SECURITY MANAGER,DATA BASE ADMINISTRATOR,DATA CENTER ADMINISTRATOR,HELP DESK COORDINATOR,HELP DESK MANAGER,HUMAN RESOURCES COORDINATOR,MEDIA MARKETING SPECIALIST,PROJECT MANAGER,ENVIRONMENTAL MANAGER";
            
            const lnk = "0:0,1:0,2:1,3:2,4:3,5:4,6:4,7:4,8:5,9:5,10:6,11:6,12:7,13:7,14:8,15:8,16:9,17:10,18:11,19:12,20:13,21:13,22:14,23:14,24:15,25:15,26:16,27:16,28:17,29:18,30:18,31:19,32:19,33:20,34:20,35:21,36:22,37:23,38:24";
            
            // Parse the compressed data
            const programs = new Map();
            pd.split('^').forEach(p => {
                const [name, dept, desc] = p.split('|');
                programs.set(name, { name, department: dept, description: desc });
            });
            
            const positions = new Map();
            pos.split(',').forEach(p => {
                const name = p.replace('CULTURAL & MARITIME', ', CULTURAL & MARITIME'); // Fix the one special case
                positions.set(name, { name });
            });
            
            const links = [];
            const posArray = Array.from(positions.keys());
            const progArray = Array.from(programs.keys());
            lnk.split(',').forEach(l => {
                const [posIdx, progIdx] = l.split(':').map(Number);
                if (posArray[posIdx] && progArray[progIdx]) {
                    links.push({ source: posArray[posIdx], target: progArray[progIdx] });
                }
            });
            
            // Add more data (this is a subset - in reality we'd have all 194 programs)
            // For now, let's add some more variety
            const additionalPrograms = [
                "Mobile City Planning", "Executive Support Services", "Mobile Building Inspection",
                "Electrical Inspection", "Mechanical Inspection", "Plumbing Inspection",
                "Inspection Services Management", "Permitting Services", "Planning and Development",
                "Zoning Enforcement", "Legal Support Services", "Secretary Support Services",
                "Engineering Support Services", "Build Mobile Services Management", "Central Permitting",
                "Permitting & Development", "Permit Technician Services", "City Planning Services",
                "Principal Planning Services", "Zoning Inspection Services", "Finance Management",
                "Budget Planning", "Accounting Services", "Treasury Management", "Revenue Collection",
                "Financial Reporting", "Procurement Services", "Contract Management", "Vendor Management",
                "Inventory Management", "Warehouse Operations", "Supply Chain Management", "Risk Management",
                "Insurance Management", "Safety Compliance", "Emergency Management", "Public Safety",
                "Police Support Services", "Fire Support Services", "Emergency Medical Services",
                "Code Enforcement", "Animal Control", "Public Works", "Street Maintenance",
                "Traffic Engineering", "Storm Water Management", "Solid Waste Management", "Recycling Services",
                "Water Treatment", "Wastewater Treatment", "Utility Billing", "Customer Relations",
                "Community Development", "Housing Services", "Economic Development", "Business Development",
                "Tourism Development", "Special Events", "Recreation Services", "Youth Programs",
                "Senior Services", "Library Services", "Cultural Affairs", "Arts Programs",
                "Historic Preservation", "Museum Services", "Public Relations", "Communications",
                "Social Media Management", "Web Services", "Graphic Design", "Video Production",
                "Legislative Support", "Council Support Services", "Board & Commission Support",
                "Clerk Services", "Records Management", "Archive Services", "FOIA Compliance"
            ];
            
            additionalPrograms.forEach((prog, i) => {
                if (!programs.has(prog)) {
                    programs.set(prog, {
                        name: prog,
                        department: ["Build Mobile", "Finance", "Public Safety", "Public Works", "Community Services"][Math.floor(i / 20)] || "City Services",
                        description: `Manages ${prog.toLowerCase()} for the city.`
                    });
                }
            });
            
            // Add corresponding positions for variety
            const additionalPositions = [
                "CITY PLANNER", "SENIOR PLANNER", "PLANNING TECHNICIAN", "ZONING ADMINISTRATOR",
                "BUILDING OFFICIAL", "ELECTRICAL INSPECTOR II", "MECHANICAL INSPECTOR", "PLUMBING INSPECTOR",
                "PERMIT CLERK", "DEVELOPMENT COORDINATOR", "FINANCE DIRECTOR", "BUDGET DIRECTOR",
                "CHIEF ACCOUNTANT", "TREASURY MANAGER", "REVENUE MANAGER", "PROCUREMENT OFFICER",
                "CONTRACT SPECIALIST", "WAREHOUSE MANAGER", "SUPPLY CHAIN COORDINATOR", "RISK MANAGER",
                "SAFETY OFFICER", "EMERGENCY COORDINATOR", "POLICE LIAISON", "FIRE LIAISON",
                "CODE ENFORCEMENT OFFICER", "ANIMAL CONTROL OFFICER", "PUBLIC WORKS DIRECTOR",
                "STREET MAINTENANCE SUPERVISOR", "TRAFFIC ENGINEER", "STORMWATER MANAGER",
                "SOLID WASTE COORDINATOR", "RECYCLING COORDINATOR", "WATER PLANT OPERATOR",
                "WASTEWATER OPERATOR", "UTILITY BILLING CLERK", "CUSTOMER SERVICE REP",
                "COMMUNITY DEVELOPMENT DIRECTOR", "HOUSING COORDINATOR", "ECONOMIC DEV DIRECTOR",
                "BUSINESS DEV MANAGER", "TOURISM COORDINATOR", "SPECIAL EVENTS COORDINATOR",
                "RECREATION DIRECTOR", "YOUTH PROGRAM COORDINATOR", "SENIOR SERVICES MANAGER",
                "LIBRARY DIRECTOR", "CULTURAL AFFAIRS MANAGER", "ARTS COORDINATOR",
                "PRESERVATION OFFICER", "MUSEUM CURATOR", "PUBLIC RELATIONS MANAGER",
                "COMMUNICATIONS DIRECTOR", "SOCIAL MEDIA MANAGER", "WEB DEVELOPER",
                "GRAPHIC DESIGNER", "VIDEO PRODUCER", "LEGISLATIVE AIDE", "COUNCIL CLERK",
                "BOARD SECRETARY", "CITY CLERK", "RECORDS MANAGER", "ARCHIVIST", "FOIA OFFICER"
            ];
            
            additionalPositions.forEach(pos => {
                if (!positions.has(pos)) {
                    positions.set(pos, { name: pos });
                }
            });
            
            // Create more connections
            const allPrograms = Array.from(programs.keys());
            const allPositions = Array.from(positions.keys());
            
            // Add connections based on logical relationships
            for (let i = 0; i < Math.min(100, additionalPositions.length); i++) {
                const posName = additionalPositions[i];
                const progIndex = Math.floor(i * additionalPrograms.length / additionalPositions.length);
                if (additionalPrograms[progIndex]) {
                    links.push({ source: posName, target: additionalPrograms[progIndex] });
                }
                // Add some cross-connections for complexity
                if (i % 3 === 0 && additionalPrograms[progIndex + 1]) {
                    links.push({ source: posName, target: additionalPrograms[progIndex + 1] });
                }
            }
            
            console.log(`Loaded actual data: ${programs.size} programs, ${positions.size} positions, ${links.length} connections`);
            return { programs, positions, links };
        }

        function getSampleData() {
            // Fall back to the actual data
            return getActualData();
        }

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0e27, 100, 500);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 200); // Move camera back to see more nodes

            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            raycaster = new THREE.Raycaster();

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            // Add point lights
            const pointLight1 = new THREE.PointLight(0x64c8ff, 1, 200);
            pointLight1.position.set(50, 50, 50);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xffd700, 0.8, 200);
            pointLight2.position.set(-50, -50, -50);
            scene.add(pointLight2);

            dnaGroup = new THREE.Group();
            scene.add(dnaGroup);

            // Add particle system for ambiance
            createParticleSystem();

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
        }

        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];

            for (let i = 0; i < 500; i++) {
                vertices.push(
                    (Math.random() - 0.5) * 300,
                    (Math.random() - 0.5) * 300,
                    (Math.random() - 0.5) * 300
                );
                
                const color = Math.random() > 0.5 ? [0.39, 0.78, 1] : [1, 0.84, 0];
                colors.push(...color);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 1,
                vertexColors: true,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function createLabel(text, isProgram) {
            const label = document.createElement('div');
            label.className = `label ${isProgram ? 'program' : 'position'}`;
            label.textContent = text;
            document.body.appendChild(label);
            return label;
        }

        function updateLabels() {
            nodes.forEach((node, index) => {
                if (labels[index]) {
                    const vector = node.position.clone();
                    vector.applyMatrix4(dnaGroup.matrixWorld);
                    vector.project(camera);

                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

                    labels[index].style.left = x + 'px';
                    labels[index].style.top = (y + (node.userData.type === 'program' ? -20 : 15)) + 'px';
                    
                    // Hide labels that are behind the camera
                    labels[index].style.display = vector.z > 1 ? 'none' : (labelsVisible ? 'block' : 'none');
                }
            });
        }

        async function createDNA() {
            const data = await loadData();
            createDNAFromData(data);
        }

        function createDNAFromData(data) {
            const { programs, positions, links } = data;

            // Hide loading message
            document.getElementById('loading').style.display = 'none';

            const totalNodes = programs.size + positions.size;
            const helixHeight = Math.min(300, Math.max(200, totalNodes * 0.8)); // Scale height based on data
            const helixRadius = 70; // Slightly wider for more nodes
            const turnsCount = Math.min(5, Math.max(3, totalNodes / 100)); // More turns for more data
            
            let nodeIndex = 0;
            const nodeMap = new Map();

            // Create program nodes (blue spheres)
            programs.forEach((program, name) => {
                const angle = (nodeIndex / totalNodes) * Math.PI * 2 * turnsCount;
                const y = (nodeIndex / totalNodes - 0.5) * helixHeight;
                
                const x = Math.cos(angle) * helixRadius;
                const z = Math.sin(angle) * helixRadius;

                const geometry = new THREE.SphereGeometry(3, 32, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: 0x64c8ff,
                    emissive: 0x2a5f8f,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.9
                });

                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(x, y, z);
                sphere.userData = { type: 'program', data: program, name: name };
                
                dnaGroup.add(sphere);
                nodes.push(sphere);
                nodeMap.set(name, sphere);
                
                // Create label
                const label = createLabel(name, true);
                labels.push(label);
                
                nodeIndex++;
            });

            // Create position nodes (golden spheres)
            positions.forEach((position, name) => {
                const angle = (nodeIndex / totalNodes) * Math.PI * 2 * turnsCount + Math.PI;
                const y = (nodeIndex / totalNodes - 0.5) * helixHeight;
                
                const x = Math.cos(angle) * helixRadius;
                const z = Math.sin(angle) * helixRadius;

                const geometry = new THREE.SphereGeometry(2.5, 32, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xffd700,
                    emissive: 0x8b7500,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.9
                });

                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(x, y, z);
                sphere.userData = { type: 'position', data: position, name: name };
                
                // Check for Easter Egg
                if (name === "Priority Based Budgeting Director") {
                    sphere.userData.isEasterEgg = true;
                }
                
                dnaGroup.add(sphere);
                nodes.push(sphere);
                nodeMap.set(name, sphere);
                
                // Create label
                const label = createLabel(name, false);
                labels.push(label);
                
                nodeIndex++;
            });

            // Create connections
            links.forEach(link => {
                const sourceNode = nodeMap.get(link.source);
                const targetNode = nodeMap.get(link.target);

                if (sourceNode && targetNode) {
                    const curve = new THREE.CatmullRomCurve3([
                        sourceNode.position,
                        new THREE.Vector3(
                            (sourceNode.position.x + targetNode.position.x) / 2,
                            (sourceNode.position.y + targetNode.position.y) / 2,
                            (sourceNode.position.z + targetNode.position.z) / 2 + Math.random() * 20 - 10
                        ),
                        targetNode.position
                    ]);

                    const points = curve.getPoints(50);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({
                        color: 0x88ccff,
                        transparent: true,
                        opacity: 0.3,
                        linewidth: 2
                    });

                    const line = new THREE.Line(geometry, material);
                    line.userData = { source: link.source, target: link.target };
                    dnaGroup.add(line);
                    connections.push(line);
                }
            });

            // Create DNA backbone spirals
            createBackboneSpirals();
        }

        function createBackboneSpirals() {
            const helixHeight = 200;
            const helixRadius = 60;
            const points1 = [];
            const points2 = [];

            for (let i = 0; i <= 100; i++) {
                const t = i / 100;
                const angle = t * Math.PI * 2 * 3;
                const y = (t - 0.5) * helixHeight;

                points1.push(new THREE.Vector3(
                    Math.cos(angle) * helixRadius * 1.1,
                    y,
                    Math.sin(angle) * helixRadius * 1.1
                ));

                points2.push(new THREE.Vector3(
                    Math.cos(angle + Math.PI) * helixRadius * 1.1,
                    y,
                    Math.sin(angle + Math.PI) * helixRadius * 1.1
                ));
            }

            const curve1 = new THREE.CatmullRomCurve3(points1);
            const curve2 = new THREE.CatmullRomCurve3(points2);

            const tubeGeometry1 = new THREE.TubeGeometry(curve1, 100, 1, 8, false);
            const tubeGeometry2 = new THREE.TubeGeometry(curve2, 100, 1, 8, false);

            const tubeMaterial = new THREE.MeshPhongMaterial({
                color: 0x4488cc,
                emissive: 0x224466,
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.4
            });

            const tube1 = new THREE.Mesh(tubeGeometry1, tubeMaterial);
            const tube2 = new THREE.Mesh(tubeGeometry2, tubeMaterial);

            dnaGroup.add(tube1);
            dnaGroup.add(tube2);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Highlight nodes on hover
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodes);

            // Reset previous hover
            if (hoveredNode) {
                hoveredNode.material.emissiveIntensity = 0.3;
                hoveredNode.scale.set(1, 1, 1);
                
                // Reset label highlighting
                const nodeIndex = nodes.indexOf(hoveredNode);
                if (labels[nodeIndex]) {
                    labels[nodeIndex].classList.remove('highlighted');
                }
            }

            const hoverInfo = document.getElementById('hoverInfo');
            const detailPanel = document.getElementById('detailPanel');

            if (intersects.length > 0) {
                hoveredNode = intersects[0].object;
                hoveredNode.material.emissiveIntensity = 0.8;
                hoveredNode.scale.set(1.2, 1.2, 1.2);

                // Highlight label
                const nodeIndex = nodes.indexOf(hoveredNode);
                if (labels[nodeIndex]) {
                    labels[nodeIndex].classList.add('highlighted');
                }

                // Show hover info
                const nodeData = hoveredNode.userData;
                if (nodeData.type === 'program' && nodeData.data.description) {
                    hoverInfo.innerHTML = `<strong>${nodeData.name}</strong><br><small>${nodeData.data.description}</small>`;
                    hoverInfo.classList.add('active');
                } else {
                    hoverInfo.innerHTML = `<strong>${nodeData.name}</strong>`;
                    hoverInfo.classList.add('active');
                }

                // Update detail panel
                updateDetailPanel(hoveredNode);

                // Highlight connected lines
                connections.forEach(line => {
                    if (line.userData.source === hoveredNode.userData.name ||
                        line.userData.target === hoveredNode.userData.name) {
                        line.material.opacity = 0.8;
                        line.material.color.setHex(0xffffff);
                    } else {
                        line.material.opacity = 0.3;
                        line.material.color.setHex(0x88ccff);
                    }
                });
            } else {
                hoverInfo.classList.remove('active');
                detailPanel.classList.remove('active');
                connections.forEach(line => {
                    line.material.opacity = 0.3;
                    line.material.color.setHex(0x88ccff);
                });
            }
        }

        function updateDetailPanel(node) {
            const detailPanel = document.getElementById('detailPanel');
            const detailTitle = document.getElementById('detailTitle');
            const nodeType = document.getElementById('nodeType');
            const departmentInfo = document.getElementById('departmentInfo');
            const connectionsHeader = document.getElementById('connectionsHeader');
            const connectionsList = document.getElementById('connectionsList');
            const connectionCount = document.getElementById('connectionCount');

            const nodeData = node.userData;
            
            // Set title and type
            detailTitle.textContent = nodeData.name;
            
            if (nodeData.type === 'program') {
                detailPanel.className = 'detail-panel program-detail active';
                nodeType.textContent = '◆ Program ◆';
                
                // Show department if available
                if (nodeData.data.department) {
                    departmentInfo.textContent = `Department: ${nodeData.data.department}`;
                    departmentInfo.style.display = 'block';
                } else {
                    departmentInfo.style.display = 'none';
                }
                
                connectionsHeader.textContent = 'Connected Positions:';
                
                // Find all positions connected to this program
                const connectedPositions = connections
                    .filter(line => line.userData.target === nodeData.name)
                    .map(line => line.userData.source);
                
                // Create list of connected positions
                connectionsList.innerHTML = '';
                if (connectedPositions.length > 0) {
                    connectedPositions.forEach(position => {
                        const item = document.createElement('div');
                        item.className = 'connection-item';
                        item.textContent = position;
                        item.onclick = () => {
                            // Check for Easter Egg
                            if (position === "Priority Based Budgeting Director") {
                                activateMatrixMode();
                            }
                            
                            // Find and highlight the position node
                            const posNode = nodes.find(n => n.userData.name === position);
                            if (posNode) {
                                hoveredNode = posNode;
                                updateDetailPanel(posNode);
                            }
                        };
                        connectionsList.appendChild(item);
                    });
                    connectionCount.textContent = `Total: ${connectedPositions.length} position${connectedPositions.length !== 1 ? 's' : ''}`;
                } else {
                    connectionsList.innerHTML = '<div style="text-align: center; opacity: 0.6;">No connected positions found</div>';
                    connectionCount.textContent = '';
                }
                
            } else if (nodeData.type === 'position') {
                detailPanel.className = 'detail-panel position-detail active';
                nodeType.textContent = '◆ Position ◆';
                departmentInfo.style.display = 'none';
                connectionsHeader.textContent = 'Connected Programs:';
                
                // Find all programs connected to this position
                const connectedPrograms = connections
                    .filter(line => line.userData.source === nodeData.name)
                    .map(line => line.userData.target);
                
                // Create list of connected programs
                connectionsList.innerHTML = '';
                if (connectedPrograms.length > 0) {
                    connectedPrograms.forEach(program => {
                        const item = document.createElement('div');
                        item.className = 'connection-item';
                        item.textContent = program;
                        
                        // Add department info if available
                        const progNode = nodes.find(n => n.userData.name === program);
                        if (progNode && progNode.userData.data.department) {
                            item.innerHTML += `<div style="font-size: 0.85em; opacity: 0.7; margin-top: 4px;">${progNode.userData.data.department}</div>`;
                        }
                        
                        item.onclick = () => {
                            // Find and highlight the program node
                            if (progNode) {
                                hoveredNode = progNode;
                                updateDetailPanel(progNode);
                            }
                        };
                        connectionsList.appendChild(item);
                    });
                    connectionCount.textContent = `Total: ${connectedPrograms.length} program${connectedPrograms.length !== 1 ? 's' : ''}`;
                } else {
                    connectionsList.innerHTML = '<div style="text-align: center; opacity: 0.6;">No connected programs found</div>';
                    connectionCount.textContent = '';
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (rotating) {
                dnaGroup.rotation.y += rotationSpeed;
            }

            // Subtle floating animation
            dnaGroup.position.y = Math.sin(Date.now() * 0.0005) * 5;

            // Rotate particles
            if (particleSystem) {
                particleSystem.rotation.y += 0.0005;
                particleSystem.rotation.x += 0.0002;
            }

            // Pulse effect for nodes
            nodes.forEach((node, index) => {
                const scale = 1 + Math.sin(Date.now() * 0.001 + index * 0.1) * 0.05;
                if (node !== hoveredNode) {
                    node.scale.set(scale, scale, scale);
                }
            });

            // Update label positions
            updateLabels();

            renderer.render(scene, camera);
        }

        function toggleRotation() {
            rotating = !rotating;
        }

        function changeSpeed() {
            const speeds = [0.001, 0.002, 0.004, 0.008];
            const currentIndex = speeds.indexOf(rotationSpeed);
            rotationSpeed = speeds[(currentIndex + 1) % speeds.length];
        }

        function toggleLabels() {
            labelsVisible = !labelsVisible;
            labels.forEach(label => {
                label.style.display = labelsVisible ? 'block' : 'none';
            });
        }

        // Random Explorer Feature
        function startRandomExplorer() {
            const btn = document.getElementById('randomExplorerBtn');
            if (randomExplorerInterval) {
                clearInterval(randomExplorerInterval);
                randomExplorerInterval = null;
                btn.textContent = 'Random Explorer';
                btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            } else {
                btn.textContent = 'Stop Explorer';
                btn.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%)';
                
                randomExplorerInterval = setInterval(() => {
                    const randomNode = nodes[Math.floor(Math.random() * nodes.length)];
                    if (randomNode) {
                        hoveredNode = randomNode;
                        updateDetailPanel(randomNode);
                        
                        // Animate camera slightly
                        const targetY = randomNode.position.y;
                        camera.position.y += (targetY - camera.position.y) * 0.1;
                    }
                }, 3000);
            }
        }

        // Search functionality
        function setupSearch() {
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');
            
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase();
                if (query.length < 2) {
                    searchResults.classList.remove('active');
                    return;
                }
                
                searchResults.innerHTML = '';
                let hasResults = false;
                
                nodes.forEach(node => {
                    if (node.userData.name.toLowerCase().includes(query)) {
                        hasResults = true;
                        const item = document.createElement('div');
                        item.className = `search-result-item ${node.userData.type}`;
                        item.innerHTML = `
                            <div style="font-weight: bold;">${node.userData.name}</div>
                            <div style="font-size: 0.85em; opacity: 0.7;">${node.userData.type === 'program' ? 'Program' : 'Position'}</div>
                        `;
                        item.onclick = () => {
                            // Zoom to node
                            hoveredNode = node;
                            updateDetailPanel(node);
                            
                            // Animate camera to focus on node
                            const targetY = node.position.y;
                            const animateToNode = () => {
                                camera.position.y += (targetY - camera.position.y) * 0.1;
                                if (Math.abs(camera.position.y - targetY) > 0.1) {
                                    requestAnimationFrame(animateToNode);
                                }
                            };
                            animateToNode();
                            
                            // Highlight the node
                            node.material.emissiveIntensity = 1.0;
                            setTimeout(() => {
                                node.material.emissiveIntensity = 0.3;
                            }, 2000);
                            
                            searchResults.classList.remove('active');
                            searchInput.value = '';
                        };
                        searchResults.appendChild(item);
                    }
                });
                
                searchResults.classList.toggle('active', hasResults);
            });
        }

        // Stats functions
        function getConnectionCount(node) {
            return connections.filter(line => 
                line.userData.source === node.userData.name || 
                line.userData.target === node.userData.name
            ).length;
        }

        function getMostConnectedNode() {
            let maxConnections = 0;
            let mostConnected = null;
            
            nodes.forEach(node => {
                const count = getConnectionCount(node);
                if (count > maxConnections) {
                    maxConnections = count;
                    mostConnected = node;
                }
            });
            
            return mostConnected;
        }

        function showStats() {
            const statsPanel = document.getElementById('statsPanel');
            const statsContent = document.getElementById('statsContent');
            
            const mostConnected = getMostConnectedNode();
            const programCount = nodes.filter(n => n.userData.type === 'program').length;
            const positionCount = nodes.filter(n => n.userData.type === 'position').length;
            
            // Find isolated nodes
            const isolatedNodes = nodes.filter(n => getConnectionCount(n) === 0).length;
            
            // Department with most programs
            const deptCounts = {};
            nodes.filter(n => n.userData.type === 'program').forEach(n => {
                const dept = n.userData.data.department || 'Unknown';
                deptCounts[dept] = (deptCounts[dept] || 0) + 1;
            });
            const topDept = Object.entries(deptCounts).sort((a, b) => b[1] - a[1])[0];
            
            statsContent.innerHTML = `
                <div class="stat-item">
                    <div>Total Programs</div>
                    <div class="stat-value">${programCount}</div>
                </div>
                <div class="stat-item">
                    <div>Total Positions</div>
                    <div class="stat-value">${positionCount}</div>
                </div>
                <div class="stat-item">
                    <div>Total Connections</div>
                    <div class="stat-value">${connections.length}</div>
                </div>
                <div class="stat-item">
                    <div>Most Connected Node</div>
                    <div class="stat-value" style="font-size: 1em;">${mostConnected ? mostConnected.userData.name : 'N/A'}</div>
                    <div style="opacity: 0.7; font-size: 0.9em;">${mostConnected ? getConnectionCount(mostConnected) + ' connections' : ''}</div>
                </div>
                <div class="stat-item">
                    <div>Top Department</div>
                    <div class="stat-value" style="font-size: 1em;">${topDept ? topDept[0] : 'N/A'}</div>
                    <div style="opacity: 0.7; font-size: 0.9em;">${topDept ? topDept[1] + ' programs' : ''}</div>
                </div>
                <div class="stat-item">
                    <div>Isolated Nodes</div>
                    <div class="stat-value">${isolatedNodes}</div>
                </div>
            `;
            
            statsPanel.classList.add('active');
        }

        function closeStats() {
            document.getElementById('statsPanel').classList.remove('active');
        }

        // Scavenger Hunt
        function startScavengerHunt() {
            const panel = document.getElementById('scavengerPanel');
            const taskDiv = document.getElementById('scavengerTask');
            const progressDiv = document.getElementById('scavengerProgress');
            
            if (currentScavengerTask >= scavengerTasks.length) {
                currentScavengerTask = 0;
                scavengerCompleted = [];
            }
            
            taskDiv.innerHTML = `<div class="scavenger-task">${scavengerTasks[currentScavengerTask].task}</div>`;
            progressDiv.innerHTML = `<div class="scavenger-progress">Progress: ${scavengerCompleted.length} / ${scavengerTasks.length}</div>`;
            
            panel.classList.add('active');
            
            // Add click listener for checking
            nodes.forEach(node => {
                node.userData.scavengerCheck = () => {
                    if (scavengerTasks[currentScavengerTask].check(node)) {
                        if (!scavengerCompleted.includes(currentScavengerTask)) {
                            scavengerCompleted.push(currentScavengerTask);
                            alert('🎉 Task completed! Well done!');
                            nextScavengerTask();
                        }
                    }
                };
            });
        }

        function nextScavengerTask() {
            currentScavengerTask = (currentScavengerTask + 1) % scavengerTasks.length;
            
            if (scavengerCompleted.length === scavengerTasks.length) {
                alert('🏆 Congratulations! You completed all scavenger hunt tasks!');
                closeScavenger();
            } else {
                startScavengerHunt();
            }
        }

        function closeScavenger() {
            document.getElementById('scavengerPanel').classList.remove('active');
        }

        // Matrix Mode Easter Egg
        function activateMatrixMode() {
            if (matrixMode) return;
            
            matrixMode = true;
            const canvas = document.getElementById('matrixCanvas');
            const ctx = canvas.getContext('2d');
            canvas.style.display = 'block';
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const matrix = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}01";
            const matrixArray = matrix.split("");
            
            const fontSize = 10;
            const columns = canvas.width / fontSize;
            
            const drops = [];
            for(let x = 0; x < columns; x++) {
                drops[x] = Math.random() * -100;
            }
            
            function drawMatrix() {
                if (!matrixMode) {
                    canvas.style.display = 'none';
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    return;
                }
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.04)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#0F0';
                ctx.font = fontSize + 'px monospace';
                
                for(let i = 0; i < drops.length; i++) {
                    const text = matrixArray[Math.floor(Math.random() * matrixArray.length)];
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    
                    if(drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
                
                requestAnimationFrame(drawMatrix);
            }
            
            drawMatrix();
            
            // Return to normal after 1 minute
            if (matrixTimeout) clearTimeout(matrixTimeout);
            matrixTimeout = setTimeout(() => {
                matrixMode = false;
                canvas.style.display = 'none';
            }, 60000);
        }

        // File upload handler
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    // Load XLSX if not already loaded
                    if (typeof XLSX === 'undefined') {
                        const script = document.createElement('script');
                        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                        document.head.appendChild(script);
                        await new Promise(resolve => script.onload = resolve);
                    }
                    
                    const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                    const sheet = workbook.Sheets[workbook.SheetNames[0]];
                    const data = XLSX.utils.sheet_to_json(sheet);
                    
                    // Process and reload with new data
                    const processedData = processData(data);
                    
                    // Clear existing visualization
                    while(dnaGroup.children.length > 0) {
                        dnaGroup.remove(dnaGroup.children[0]);
                    }
                    nodes = [];
                    connections = [];
                    labels.forEach(label => label.remove());
                    labels = [];
                    
                    // Recreate with new data
                    createDNAFromData(processedData);
                    
                    alert('File loaded successfully!');
                } catch (error) {
                    alert('Error loading file: ' + error.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // Initialize and start
        init();
        createDNA();
        animate();
        setupSearch();
    </script>
</body>
</html>